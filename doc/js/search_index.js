var search_data = {"index":{"searchIndex":["mm","deltas","metric","pairs","ratio","scaling","search","*()","+()","-()","/()","<=>()","abs()","abs()","absolute()","add_to_path()","backtrack()","calculate_cost()","call()","change_interval()","combinatorial()","cost_function()","current_cost()","direction()","factors()","find()","find_from_point()","from_s()","from_vector()","from_yaml()","get_adjacent_points()","get_global()","get_sorted_adjacent_points()","inter_delta=()","intra_delta=()","linear()","log_ratio()","made_it?()","mean()","new()","new()","new()","none()","pair=()","ratio()","reciprocal()","relative()","scale=()","string_to_ratio()","tenney()","to_f()","to_s()","to_vector()","history","manifest","readme","roadmap"],"longSearchIndex":["mm","mm::deltas","mm::metric","mm::pairs","mm::ratio","mm::scaling","mm::search","mm::ratio#*()","mm::ratio#+()","mm::ratio#-()","mm::ratio#/()","mm::ratio#<=>()","mm::deltas::abs()","mm::ratio#abs()","mm::scaling::absolute()","mm::search#add_to_path()","mm::search#backtrack()","mm::search#calculate_cost()","mm::metric#call()","mm::ratio::change_interval()","mm::pairs#combinatorial()","mm::search#cost_function()","mm::search#current_cost()","mm::deltas::direction()","mm::ratio#factors()","mm::search#find()","mm::search#find_from_point()","mm::ratio::from_s()","mm::ratio::from_vector()","mm::ratio::from_yaml()","mm::search#get_adjacent_points()","mm::scaling::get_global()","mm::search#get_sorted_adjacent_points()","mm::metric#inter_delta=()","mm::metric#intra_delta=()","mm::pairs#linear()","mm::deltas::log_ratio()","mm::search#made_it?()","mm::deltas::mean()","mm::metric::new()","mm::ratio::new()","mm::search::new()","mm::scaling::none()","mm::metric#pair=()","mm::deltas::ratio()","mm::ratio#reciprocal()","mm::scaling::relative()","mm::metric#scale=()","mm::ratio::string_to_ratio()","mm::deltas::tenney()","mm::ratio#to_f()","mm::ratio#to_s()","mm::ratio::to_vector()","","","",""],"info":[["MM","","MM.html","",""],["MM::Deltas","","MM/Deltas.html","",""],["MM::Metric","","MM/Metric.html","",""],["MM::Pairs","","MM/Pairs.html","",""],["MM::Ratio","","MM/Ratio.html","",""],["MM::Scaling","","MM/Scaling.html","",""],["MM::Search","","MM/Search.html","",""],["*","MM::Ratio","MM/Ratio.html#method-i-2A","(other)",""],["+","MM::Ratio","MM/Ratio.html#method-i-2B","(other)",""],["-","MM::Ratio","MM/Ratio.html#method-i-2D","(other)",""],["/","MM::Ratio","MM/Ratio.html#method-i-2F","(other)",""],["<=>","MM::Ratio","MM/Ratio.html#method-i-3C-3D-3E","(other)",""],["abs","MM::Deltas","MM/Deltas.html#method-c-abs","(n)",""],["abs","MM::Ratio","MM/Ratio.html#method-i-abs","()",""],["absolute","MM::Scaling","MM/Scaling.html#method-c-absolute","(pairs)",""],["add_to_path","MM::Search","MM/Search.html#method-i-add_to_path","(point)",""],["backtrack","MM::Search","MM/Search.html#method-i-backtrack","()",""],["calculate_cost","MM::Search","MM/Search.html#method-i-calculate_cost","(candidates)",""],["call","MM::Metric","MM/Metric.html#method-i-call","(v1, v2)","<p>Public: Gets the distance between two vectors, according to the Metric\nobject. Since <code>Metric</code> can be duck-typed …\n"],["change_interval","MM::Ratio","MM/Ratio.html#method-c-change_interval","(point, index, interval)",""],["combinatorial","MM::Pairs","MM/Pairs.html#method-i-combinatorial","(vector)",""],["cost_function","MM::Search","MM/Search.html#method-i-cost_function","(*args)",""],["current_cost","MM::Search","MM/Search.html#method-i-current_cost","()",""],["direction","MM::Deltas","MM/Deltas.html#method-c-direction","(n)","<p>Have to scale by 0.5 in order to normalize to a max distance of 1.0\n"],["factors","MM::Ratio","MM/Ratio.html#method-i-factors","()","<p>Works very similarly to the Prime::prime_division method, except that\nfactors in the numerator are positive, …\n"],["find","MM::Search","MM/Search.html#method-i-find","()","<p>Finds a vector beginning from the starting point\n"],["find_from_point","MM::Search","MM/Search.html#method-i-find_from_point","(point)",""],["from_s","MM::Ratio","MM/Ratio.html#method-c-from_s","(r)",""],["from_vector","MM::Ratio","MM/Ratio.html#method-c-from_vector","(vector)",""],["from_yaml","MM::Ratio","MM/Ratio.html#method-c-from_yaml","(yaml_string)","<p>Loads a sequence of MM::Ratios from a YAML file.\n"],["get_adjacent_points","MM::Search","MM/Search.html#method-i-get_adjacent_points","(*args)",""],["get_global","MM::Scaling","MM/Scaling.html#method-c-get_global","(max)","<p>Note: a bit hacky. But anything starting with “get_” should be considered a\nmeta-scaling method. …\n"],["get_sorted_adjacent_points","MM::Search","MM/Search.html#method-i-get_sorted_adjacent_points","(*args)",""],["inter_delta=","MM::Metric","MM/Metric.html#method-i-inter_delta-3D","(inter_delta)","<p>Public: Setter method for inter_delta.\n<p>inter_delta - Either a Proc that can process as an inter_delta …\n"],["intra_delta=","MM::Metric","MM/Metric.html#method-i-intra_delta-3D","(intra_delta)","<p>Public: Setter method for intra_delta.\n<p>intra_delta - Either a Proc that can process the intra_delta, or …\n"],["linear","MM::Pairs","MM/Pairs.html#method-i-linear","(vector)",""],["log_ratio","MM::Deltas","MM/Deltas.html#method-c-log_ratio","(n)","<p>Accepts a tuple of anything that Math.log2 can handle\n"],["made_it?","MM::Search","MM/Search.html#method-i-made_it-3F","()",""],["mean","MM::Deltas","MM/Deltas.html#method-c-mean","(n)",""],["new","MM::Metric","MM/Metric.html#method-c-new","(ordered: true, pair: nil, scale: nil, intra_delta: nil, inter_delta: nil)","<p>Constructor for the Metric object.\n<p>ordered - [Boolean]\n\n<pre>Controls whether metric is ordered</pre>\n"],["new","MM::Ratio","MM/Ratio.html#method-c-new","(n, d)",""],["new","MM::Search","MM/Search.html#method-c-new","(starting_point, delta = 0.001)",""],["none","MM::Scaling","MM/Scaling.html#method-c-none","(pairs)","<p>Scale to the max across both vector\n"],["pair=","MM::Metric","MM/Metric.html#method-i-pair-3D","(pair)","<p>Public: Setter method for pair.\n<p>pair - [Symbol, #call]\n\n<pre>Method of +MM::Deltas+, or where +Object#call+ ...</pre>\n"],["ratio","MM::Deltas","MM/Deltas.html#method-c-ratio","(n)",""],["reciprocal","MM::Ratio","MM/Ratio.html#method-i-reciprocal","()",""],["relative","MM::Scaling","MM/Scaling.html#method-c-relative","(pairs)","<p>Scale each vector to its own max\n"],["scale=","MM::Metric","MM/Metric.html#method-i-scale-3D","(scale)","<p>Public: Setter method for scale.\n<p>scale - Either a Proc that can process scaling, or a Symbol to look up …\n"],["string_to_ratio","MM::Ratio","MM/Ratio.html#method-c-string_to_ratio","(string)",""],["tenney","MM::Deltas","MM/Deltas.html#method-c-tenney","(n)","<p>Accepts a tuple where the quotient responds to #numerator and #denominator\n"],["to_f","MM::Ratio","MM/Ratio.html#method-i-to_f","()",""],["to_s","MM::Ratio","MM/Ratio.html#method-i-to_s","()",""],["to_vector","MM::Ratio","MM/Ratio.html#method-c-to_vector","(point)",""],["History","","History_txt.html","","<p>1.0.0 / 2014-04-09\n<p>1 major enhancement\n<p>Birthday!\n"],["Manifest","","Manifest_txt.html","","<p>.autotest .minitest.rb .travis.yml Gemfile Gemfile.lock History.txt\nManifest.txt README.rdoc ROADMAP.txt …\n"],["README","","README_rdoc.html","","<p><img src=\"https://codeclimate.com/github/andrewcsmith/mm.png\" />\n<p><img src=“https://travis-ci.org/andrewcsmith/mm.svg?branch=master” …\n"],["ROADMAP","","ROADMAP_txt.html","","<p>Complete functions for getting combinatorial and adjacent pairs\n\n<pre>- fix any problems with shapes, test more ...</pre>\n"]]}}